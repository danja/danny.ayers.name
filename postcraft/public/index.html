<!DOCTYPE html>
<html lang="en">

<head>
    <title>Rawer</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <!-- #:todo remove when stable -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <link rel="stylesheet" href="/css/fonts.css" type="text/css" />
    <link rel="stylesheet" href="/css/grid-columns.css" type="text/css" />
    <link rel="stylesheet" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/css/menu.css" type="text/css" />

</head>

<body>
    <header id="main-header">
        <h1 class="h-title">
           Raw<em>er</em>
        </h1>
    </header>
    <div class="grid-container">
        <div class="main-grid-item directory">
            <p><strong>Under Construction</strong></p>
            <p></p>
        </div>
        <div class="main-grid-item articles">
            <article>
                <!-- ARTICLE CONTENT -->

<article class="post-content">
    <h1>Voltage Controlled Motor Module</h1>
<p>Demo vid : <a href="https://www.youtube.com/watch?v=KZEP5wFOWAk">VCMM</a></p>
<p>Schematic :</p>
<p><img src="/images/2025-06/motor-module-schematic.jpeg" alt="schematic"></p>
<p>This worked on the 3rd attempt. First try, nothing happened but one transistor got hot. Then I discovered I&#39;d got the collector wires the wrong way around. I thought I must have fried the transistors, but maybe not, after I&#39;d replaced them I experimented a bit more. My estimate for a resistor to go in series with the motor had been way out (120R), it needed something <em>really</em> low. But it occurred to me that an inductance should work there, and I had a old PCB (from a satellite tuner PSU) on the desk next to me with the perfect candidate. I&#39;d got the old board there for the 1000uF 16v caps. I didn&#39;t bother breadboarding, went straight to stripboard. It would either work or not. The components that were candidates for tweaking were easy access.</p>
<p><img src="/images/2025-06/motor-module.jpeg" alt="pcb"></p>
<p>This time it actually worked. After trying it for a few seconds I felt to see if the transistors were getting warm. Burnt my fingers. Motors really aren&#39;t my thing. So I made a couple of little heatsinks and hooked it up to the modular for the vid.</p>
<p>I think what I&#39;ll do is try it with a PSU of its own next. With a dummy load first, to see if the circuit is behaving as I&#39;d expected. I really don&#39;t get why it should be drawing so much current with such a farty little motor, unless the transistors are biased on when they shouldn&#39;t be. Dunno. The motor is the main unknown for me.
 </p>

</article>
<p class="post-title h-cinzel">
    <a href="http://danny.ayers.name/entries/2025-06-25_motor-module.html">
        Voltage Controlled Motor Module
    </a>
</p> <em></em><!-- ARTICLE CONTENT -->

<article class="post-content">
    <h1>Distortion Module</h1>
<p>I think I already posted this schematic :</p>
<p><img src="/images/2025-06/distortion.png" alt="distortion schematic"></p>
<p>Since then I soldered it up and made a front panel. It worked on the second attempt!</p>
<p>First time I&#39;d labeled the power connector back-to-front. Which was annoying since I knew the red wire on Eurorack cables was perversely the negative. I must have doubled on it. Anyway, it fried the op-amp. Horrible to desolder.</p>
<p> <img src="/images/2025-06/fried.jpeg" alt="fried op amp"></p>
<p> The front panel went well :</p>
<p> <img src="/images/2025-06/fp.jpeg" alt="fp"></p>
<p> <strong>One Simple Trick!</strong> - print onto glossy paper, laminate.</p>
<p> End result was reasonably smart -</p>
<p> <img src="/images/2025-06/distortion-fp.png" alt="distortion module"></p>
<p> I couldn&#39;t be bothered tweaking the layout further.</p>
<p> The font is <a href="https://www.cdnfonts.com/thrums-serif.font">Thrums Serif</a>, btw. I designed it a few years back because I wanted to see how it was done, and wanted one that worked for me on web pages. I didn&#39;t really get it to look good on web pages, but serendipity - exactly what I want for front panels.</p>

</article>
<p class="post-title h-cinzel">
    <a href="http://danny.ayers.name/entries/2025-06-25_distortion-module.html">
        Distortion Module
    </a>
</p> <em></em><!-- ARTICLE CONTENT -->

<article class="post-content">
    <h1>Wave Function Collapse for Sounds</h1>
<p>An LV2 plugin.</p>
<p>Repo : <a href="https://github.com/danja/collapse-lv2">https://github.com/danja/collapse-lv2</a></p>
<p>Demo : <a href="https://www.youtube.com/watch?v=aXFnkI-dZOA">YouTube</a> (hope that works, I got a copyright warning)</p>
<p>It generates signal based on what it&#39;s seen, is a kind of machine learning lite. It&#39;s very noisy. Which is what I was hoping for. Aside from the obvious noise use, it <em>may</em> be useful as waveform shaper.</p>
<p>I stumbled on <a href="https://github.com/mxgmn/WaveFunctionCollapse">WaveFunctionCollapse</a>, &quot;This program generates bitmaps that are locally similar to the input bitmap.&quot;. It occurred to me that the same algorithm might be usable on audio streams. I wrote a long prompt for <a href="https://www.deepseek.com/en">DeepSeek</a> which had a good long discussion with itself before producing the material below. This I passed to <a href="https://claude.ai/new">Claude chat</a> together with the instructions for it to make an <a href="https://en.wikipedia.org/wiki/LV2">LV2 plugin</a> for me. I want to use it in <a href="https://www.reaper.fm/">Reaper</a>, my DAW of choice.
(I&#39;ve already had a go at <strong>vibe coding</strong> with <a href="https://github.com/danja/amen-chaos">amen-chaos</a> and <a href="https://github.com/danja/midi-chaos-amen">midi-chaos-amen</a> with considerable success, as far as I took them). Claude gave me some patchy files which I stuck up at <a href="https://github.com/danja/collapse-lv2">GitHub</a> before setting <a href="https://www.anthropic.com/claude-code">Claude Code</a> on them.</p>
<p><del>So far I&#39;ve not got anything usable, I ran out of Claude tokens. Apparently <a href="https://codeassist.google/">Google Gemini</a> for coding is now free, so I may give that a shot later.</del> Gemini was slow. Went back to Claude and now <strong>it works!</strong></p>
<p>Anyhow, below is what DeepSeek gave me, it has the basic idea. <del>I&#39;ve a feeling it won&#39;t be any good without taking into account the periodicity of the input. This could potentially operate at the waveform level, or (depending on how it performs) over beats or bars. Dunno.</del></p>
<p>I added period detection with autocorrelation in at the start. It&#39;s very picky about which settings will actually produce a processed output. But it really messes things up, which is exactly what I was hoping for.</p>
<hr>
<p>To apply the wave function collapse (WFC) technique to audio waveforms in near real-time, we reinterpret the grid-based approach for time-series data. Here&#39;s a conceptual adaptation and JavaScript implementation:</p>
<h3>Core Concept Adaptation:</h3>
<ol>
<li><p><strong>Grid Representation</strong>:</p>
<ul>
<li><strong>X-axis</strong>: Represents time (one cycle or window of the waveform).</li>
<li><strong>Y-axis</strong>: Represents <strong>quantized amplitude levels</strong> (discrete buckets for continuous sample values).</li>
<li><strong>Z-axis (optional)</strong>: Encodes <strong>local patterns</strong> (e.g., sequences of amplitude changes).</li>
</ul>
</li>
<li><p><strong>Pattern Extraction</strong>:</p>
<ul>
<li>Slice the input waveform into overlapping windows (e.g., 10-sample segments).</li>
<li>Quantize amplitudes (e.g., 256 levels) to create discrete &quot;tiles&quot;.</li>
<li>Catalog valid neighbor transitions (e.g., which 10-sample blocks can follow each other).</li>
</ul>
</li>
<li><p><strong>Real-Time Generation</strong>:</p>
<ul>
<li>Maintain a &quot;collapsing&quot; buffer of recent samples (context window).</li>
<li>For each new sample, resolve constraints by selecting valid patterns that match the context.</li>
<li>Output the next sample from the chosen pattern.</li>
</ul>
</li>
</ol>
<hr>
<h3>JavaScript Implementation:</h3>
<pre><code class="language-javascript">class WaveformWFC {
  constructor(inputSamples, patternSize = 10, quantLevels = 256) {
    this.patternSize = patternSize;
    this.quantLevels = quantLevels;
    this.patterns = new Map(); // pattern -&gt; {nextPatterns: Set, count: number}

    // Quantize input [-1, 1] to discrete levels
    this.quantize = (sample) =&gt;
      Math.max(0, Math.min(quantLevels - 1,
        Math.floor((sample + 1) * quantLevels / 2)));

    this.dequantize = (level) =&gt;
      (level / (quantLevels - 1)) * 2 - 1;

    this.extractPatterns(inputSamples);
  }

  extractPatterns(samples) {
    // Build patterns from sliding windows
    for (let i = 0; i &lt; samples.length - this.patternSize; i++) {
      const window = samples.slice(i, i + this.patternSize);
      const quantPattern = window.map(s =&gt; this.quantize(s));
      const key = quantPattern.join(&#39;,&#39;);

      // Track pattern frequency and allowed successors
      if (!this.patterns.has(key)) {
        this.patterns.set(key, { nextPatterns: new Set(), count: 0 });
      }
      const data = this.patterns.get(key);
      data.count++;

      // Record valid next pattern (overlapping window)
      if (i &lt; samples.length - this.patternSize - 1) {
        const nextWindow = samples.slice(i + 1, i + this.patternSize + 1);
        const nextKey = nextWindow.map(s =&gt; this.quantize(s)).join(&#39;,&#39;);
        data.nextPatterns.add(nextKey);
      }
    }
  }

  generateSample(context) {
    // Quantize recent context (patternSize - 1 samples)
    const quantContext = context.map(s =&gt; this.quantize(s));
    const contextKey = quantContext.join(&#39;,&#39;);

    // Find patterns starting with current context
    const candidates = [];
    for (const [pattern, data] of this.patterns) {
      const patternArr = pattern.split(&#39;,&#39;).map(Number);
      const matchesContext = quantContext.every(
        (val, i) =&gt; val === patternArr[i]
      );

      if (matchesContext) {
        // Weight by occurrence frequency
        for (let i = 0; i &lt; data.count; i++) {
          candidates.push(patternArr[patternArr.length - 1]); // Last sample in pattern
        }
      }
    }

    // Fallback: Random sample if no candidates
    if (candidates.length === 0) {
      return Math.random() * 2 - 1; // [-1, 1]
    }

    // Random weighted selection
    const nextLevel = candidates[Math.floor(Math.random() * candidates.length)];
    return this.dequantize(nextLevel);
  }
}

// Usage Example
const audioContext = new AudioContext();
const inputSamples = [...]; // Float32Array from source audio

const wfc = new WaveformWFC(inputSamples);
const outputBuffer = new Float32Array(44100); // 1sec buffer
let context = new Array(wfc.patternSize - 1).fill(0); // Initial silence

for (let i = 0; i &lt; outputBuffer.length; i++) {
  outputBuffer[i] = wfc.generateSample(context);

  // Update context (remove oldest, add new sample)
  context.shift();
  context.push(outputBuffer[i]);
}

// Play generated audio
const buffer = audioContext.createBuffer(1, outputBuffer.length, 44100);
buffer.copyToChannel(outputBuffer, 0);
const source = audioContext.createBufferSource();
source.buffer = buffer;
source.connect(audioContext.destination);
source.start();
</code></pre>
<h3>Key Optimizations for Real-Time:</h3>
<ol>
<li><strong>Context Hashing</strong>:<ul>
<li>Precompute lookup tables for quantized context keys to candidate patterns.</li>
</ul>
</li>
<li><strong>Approximate Matching</strong>:<ul>
<li>Use Euclidean distance thresholds for noisy inputs.</li>
</ul>
</li>
<li><strong>Pattern Pruning</strong>:<ul>
<li>Discard low-frequency patterns to reduce state space.</li>
</ul>
</li>
<li><strong>Overlap Handling</strong>:<ul>
<li>Generate samples in blocks (e.g., 128 samples) to amortize lookup costs.</li>
</ul>
</li>
</ol>
<h3>How Structure is Preserved:</h3>
<ol>
<li><strong>Local Constraints</strong>:<ul>
<li>Transition rules enforce that amplitude sequences (e.g., attack-decay in notes) replicate input behaviors.</li>
</ul>
</li>
<li><strong>Global Coherence</strong>:<ul>
<li>Weighted pattern selection maintains statistical properties (e.g., amplitude distribution).</li>
</ul>
</li>
<li><strong>Continuity</strong>:<ul>
<li>Overlapping context buffers prevent discontinuities between generated segments.</li>
</ul>
</li>
</ol>
<p>This approach mirrors WFC&#39;s constraint-solving in a temporal domain, transforming input waveforms into novel outputs with similar micro/macro structures.
 </p>

</article>
<p class="post-title h-cinzel">
    <a href="http://danny.ayers.name/entries/wfc-synth.html">
        Wave Function Collapse for Sounds
    </a>
</p> <em></em><!-- ARTICLE CONTENT -->

<article class="post-content">
    <h1>Journal 2025-06-23</h1>
<h2>New Domain : tensegrity.it</h2>
<p>I&#39;ve added a new DNS domain to my collection, so I now have :</p>
<ol>
<li><a href="https://danny.ayers.name">danny.ayers.name</a> - my personal site (this blog)</li>
<li><a href="https://hyperdata.it">hyperdata.it</a> - my quasi-company site</li>
<li><a href="https://strandz.it">strandz.it</a> - for a project, in planning</li>
<li><a href="https://tensegrity.it">tensegrity.it</a> - my current raft of code projects</li>
</ol>
<p>They are all undeniably <strong>Under Construction</strong>.</p>
<p>The new one came about because I realised that my the things I&#39;m working on strongly resemble a <a href="https://en.wikipedia.org/wiki/Tensegrity">tensegrity structure</a>. Only after setting up a <a href="https://github.com/danja/tensegrity">GitHub repo</a> to record this did I think to check for the domain name. Right now the repo just contains a sketchy overview. I&#39;ll use the new domain for now just as a tech blog, keeping the <code>.name</code> domain for non-coding stuff.  
 </p>

</article>
<p class="post-title h-cinzel">
    <a href="http://danny.ayers.name/entries/2025-06-23_journal.html">
        Journal 2025-06-23
    </a>
</p> <em></em><!-- ARTICLE CONTENT -->

<article class="post-content">
    <h1>Simple Distortion Circuit</h1>
<p><a href="https://www.youtube.com/watch?v=mMDBcwWSbNc">rough demo video</a></p>
<p>I was a bit frustrated not having a convenient distortion module on my setup so I designed one. After a handful of sketches and a little bit of breadboarding, this is what I came up with :</p>
<p><img src="/images/2025-06/distortion.png" alt="Schematic"></p>
<p>Its operation is a lot more straightforward than it looks.</p>
<p>The left-hand op amp is just operating as a textbook inverting amp, gain of x1 to about x10. The right-hand hand op amp is having more fun. The core idea is that of a <a href="https://en.wikipedia.org/wiki/Log_amplifier">log amplifier</a>, the &quot;transdiode&quot; configuration. It&#39;s using the exponential characteristic of a bipolar transistor in the feedback of the op amp to achieve a logarithmic transfer function. In other words, <strong>soft clipping</strong>. Tube overdrive style, if you&#39;re an American guitar head. The magic part of this configuration is that the combination of NPN and PNP transistors, simply one on top of the other, actually works to make the function work on negative-going signals in mirror image. <em>No way that would work!</em> But it does.</p>
<p>I&#39;ve flipped the op amp inputs so this is non-inverting - I&#39;d forgotten, I was going to make the input amp non-inverting too... Reason being, ideally I wanted it DC-coupled so it could be an interesting function on control voltages too. But when wired up to modules this messed up its use on signals - the <em>your guess is as good as mine</em> Eurorack standard voltage levels. So I AC coupled it, hence the cap on input &amp; output. (The 100p cap in the feedback is my cargo cult attempt at ensuring HF stability. It makes no audible difference).</p>
<p>The variable resistance in the feedback effectively adjusts when the transistors start getting curvy. When it&#39;s down to the 10k I couldn&#39;t see or hear any difference from the input signal, is effectively unity gain. Wide open, the curve starts early, it sounds like hard clipping.</p>
<p>The pair of diodes was the result of messing about. I initially tried them from the signal path between the first op amp and the second, to ground. I expected a buzzier hard clipping at a lower level, until the log-ish follower was wound up for gain. But it wasn&#39;t very interesting. What was interesting is the current config. I&#39;ll leave it to someone better at sums than me to figure out properly, but intuitively I would have expected this to have extended the linearish low level region up by the voltage drop until transistor bias starts kicking in, with the effect of raising the curvy roof. Nah. The result in practice is that it gives an audible boost overall. When the bases are direct to ground, the transfer curve seems rather kinky, not as smooth as it should be. With the diodes in circuit, it have a much more elegant curve. My technical explanation is something something op amp compensating something bias something.</p>
<p>Here&#39;s it on the breadboard :</p>
<p><img src="/images/2025-06/breadboard.png" alt="Breadboard"></p>
<p>I&#39;ve got all the music room gear in the office while I redecorate, and the desktop machine I usually run a &#39;scope (Bitscope) on was busy entertaining Claude. So it gave me a chance to use my breadboard. It is literally built on a plastic breadboard, hat tip to the originators. As well as the horrid little Chinese scope and signal generator there&#39;s a home-hack audio amp, underneath a +/- 12v, +5 PSU in a tin I got from Penny Market. Got 3.5 mm sockets, various pots, a few switches. The idea is I can take prototypes to the modular in a Mohammed-mountain kind of deal. Only after I&#39;d made it did I hear about the Erica Synths (they who do collabs with the wonderful DIYer <a href="https://www.youtube.com/@MoritzKlein0">Moritz Klein</a>) do a ready-made, neat version : the <a href="https://www.ericasynths.lv/shop/diy-kits-1/edu-diy-labor/">EDU DIY Labor</a>. Hey ho. Saved meself a few quid.</p>
<p>Oh yeah, back to the circuit. Nothing&#39;s critical. For op amps I used a TL072, transistors a BC109 &amp; BC179, generic highish gain silicon small signal I happened to have. To keep it balanced up &amp; down you probably want a complementary pair like that. I plan to slap the circuit on a scrap of stripboard, cut &amp; drill a bit of aluminium sheet for front panel, couple of hours work max, my itch scratched.
 </p>

</article>
<p class="post-title h-cinzel">
    <a href="http://danny.ayers.name/entries/simple-distortion-circuit.html">
        Simple Distortion Circuit
    </a>
</p> <em></em>
            </article>
        </div>
        <div class="main-grid-item about">
            <!--
            <h2>About</h2>
            
            -->
        </div>
    </div>
    <script src="js/menu.js"></script>
</body>

</html>