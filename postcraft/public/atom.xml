<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Rawer</title>
    todo

    <link href=""/>
    <updated></updated>
    <id></id>
    <author>
        <name></name>

    </author>
<entry>
    <title>
        This feed isn't formatted properly yet
   </title>
   <content>
      <h1>Journal 2025-05-16</h1>
<p><strong>Blog <del>might be</del> is back!</strong></p>
<p>Ok, that was arduous. I had to rewrite a big chunk of the core code for #:transmissions, my pipeliney thing. It&#39;d simply got too spaghettified. But barring a handful of minor misalignment problems, it&#39;s working again. #:postcraft is the canonical app, this blog is published using it.</p>
<p><img src="media/images/2025-05/blog-back.jpeg" alt="Cartoon illustration"></p>
<p>#:postcraft is possibly the world&#39;s most over-engineered Static Site Builder. After crawling dirs for markdown files it posts the material off to a SPARQL store. Then another pipeline is set up to query the store and render the site.</p>
<p>The over-engineering is intentional. The data in the SPARQL store is there for other uses. A couple of days ago I got #:semem, my Semantic Memory thing to create embeddings from the content and allow this to be used for &#39;semantic search&#39;.</p>
<p>Btw, the #:semtags do have a purpose : <strong>Semantic Hashtags</strong>. I&#39;ve a very short, simly spec written for them here somewhere - the <code>#:</code> marker says the string that follows has some kind of significance in the the current domain. In practice, they are a markdown extension that I intend to use here by replacing with a link to a query on a service - a search, but ultimately using #semem as the engine.</p>
<p>For a first pass I&#39;m thinking of templating a query, something like :</p>
<pre><code class="language-sparql">PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX skos: &lt;http://www.w3.org/2004/02/skos/core#Concept&gt;

SELECT ?resources WHERE {

    ?c a skos:Concept ;
       rdfs:label ?label ;
       rdfs:seeAlso ?resources .

   FILTER regex(?label, &quot;^{{semtag}}&quot;, &quot;i&quot;)
}
</code></pre>
<p>Elsewhere I&#39;ll put together some basic definitions.
 </p>
<h1>Journal 2025-05-10</h1>
<p>Setting up Linux Mint. 
 </p>
<h1>Journal 2025-05-07</h1>
<h1>Journal 2025-05-03</h1>
<p>Here’s the trace of where your message goes and how it should reach ProcessorImpl.getProperty:</p>
<p>CLI Entry:
You run:</p>
<p>This calls the bash script trans, which runs node <a href="http://_vscodecontentref_/2">run.js</a> ....</p>
<p>Argument Parsing:
In run.js, yargs parses the --message argument and coerces it to a JS object.</p>
<p>CommandUtils:
CommandUtils.handleOptions is called, which calls CommandUtils.parseOrLoadMessage.
This wraps your message as { payload: { theSettingProperty: ... } }.</p>
<p>AppManager:
AppManager.start(message) is called with the message object.
The message is merged with app context, then passed to each transmission’s process(message).</p>
<p>Transmission:
The transmission’s process(message) method is called, which passes the message to each processor in the pipeline.</p>
<p>Processor (TestSetting):
The processor’s process(message) is called.
In TestSetting.js, it calls this.getProperty(ns.trn.theSettingProperty).</p>
<p>ProcessorImpl.getProperty:</p>
<p>Checks if the property is in the message (via propertyInMessage).
If not, checks settings/config.
 </p>
<h1>Journal 2025-04-30</h1>
<p>I broke #:transmissions!</p>
<h2>Web fs prompt</h2>
<p>I would like you to write a node js HTTP server app called <code>WebStore</code> using ES modules and the express library that will do the following :</p>
<ul>
<li>handle HTTP GET, POST, PUT, DELETE, using a preset filesystem subdirectory on the server to store</li>
<li>there will be HTTP Basic authentication on PUT, POST and DELETE with username:password</li>
<li>content/media type will be handled using the standard technique through filename extensions</li>
<li>run on port 4500</li>
</ul>
<p>This will be put on an existing server running nginx, which will proxy to port 4500. Please create configuration <code>webstorage.conf</code></p>
<p>Additionally I&#39;d like a simple object-oriented command-line client app called <code>wstore</code> using yargs library in ES modules that supports the same core functionality as curl.</p>
<p>Base URL will correspond the server-side fs dir, so eg. <code>http://hyperdata.it/files</code> might correspond to <code>/home/hyperdata/webstore/files</code>. The filename with refer to both the local file and the target resource on the server.</p>
<p>Please render all source code as complete, individual artifacts.</p>
<p>#:todo</p>
<p>Refactor #:semem</p>
<ul>
<li>rebuilt sparql graphs</li>
</ul>

      </content>
    </entry>
</feed>